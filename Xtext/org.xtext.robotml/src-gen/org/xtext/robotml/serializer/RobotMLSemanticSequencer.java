/*
 * generated by Xtext 2.41.0
 */
package org.xtext.robotml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.robotml.services.RobotMLGrammarAccess;
import robotML.Assignation;
import robotML.Backward;
import robotML.Binary;
import robotML.Block;
import robotML.Condition;
import robotML.Forward;
import robotML.FunctionCall;
import robotML.FunctionDeclaration;
import robotML.GetClock;
import robotML.GetSensor;
import robotML.GetSpeed;
import robotML.Leftward;
import robotML.Rightward;
import robotML.RobotMLPackage;
import robotML.Rotate;
import robotML.SetClock;
import robotML.Unary;
import robotML.VariableDeclaration;
import robotML.VariableRef;
import robotML.setSpeed;

@SuppressWarnings("all")
public class RobotMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobotMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotMLPackage.ASSIGNATION:
				sequence_Assignation(context, (Assignation) semanticObject); 
				return; 
			case RobotMLPackage.BACKWARD:
				sequence_Backward(context, (Backward) semanticObject); 
				return; 
			case RobotMLPackage.BINARY:
				sequence_Binary(context, (Binary) semanticObject); 
				return; 
			case RobotMLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RobotMLPackage.BOOLEAN:
				sequence_Boolean(context, (robotML.Boolean) semanticObject); 
				return; 
			case RobotMLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case RobotMLPackage.FLOAT:
				sequence_Float(context, (robotML.Float) semanticObject); 
				return; 
			case RobotMLPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case RobotMLPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case RobotMLPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case RobotMLPackage.GET_CLOCK:
				sequence_GetClock(context, (GetClock) semanticObject); 
				return; 
			case RobotMLPackage.GET_SENSOR:
				sequence_GetSensor(context, (GetSensor) semanticObject); 
				return; 
			case RobotMLPackage.GET_SPEED:
				sequence_GetSpeed(context, (GetSpeed) semanticObject); 
				return; 
			case RobotMLPackage.INTEGER:
				sequence_Integer(context, (robotML.Integer) semanticObject); 
				return; 
			case RobotMLPackage.LEFTWARD:
				sequence_Leftward(context, (Leftward) semanticObject); 
				return; 
			case RobotMLPackage.RIGHTWARD:
				sequence_Rightward(context, (Rightward) semanticObject); 
				return; 
			case RobotMLPackage.ROTATE:
				sequence_Rotate(context, (Rotate) semanticObject); 
				return; 
			case RobotMLPackage.SET_CLOCK:
				sequence_SetClock(context, (SetClock) semanticObject); 
				return; 
			case RobotMLPackage.STRING:
				sequence_String0(context, (robotML.String) semanticObject); 
				return; 
			case RobotMLPackage.UNARY:
				sequence_Unary(context, (Unary) semanticObject); 
				return; 
			case RobotMLPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case RobotMLPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case RobotMLPackage.VOID:
				sequence_Void(context, (robotML.Void) semanticObject); 
				return; 
			case RobotMLPackage.SET_SPEED:
				sequence_setSpeed(context, (setSpeed) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assignation returns Assignation
	 *     Statement returns Assignation
	 *
	 * Constraint:
	 *     (variableDecl=VariableDeclaration expression=Expression)
	 * </pre>
	 */
	protected void sequence_Assignation(ISerializationContext context, Assignation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.ASSIGNATION__VARIABLE_DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.ASSIGNATION__VARIABLE_DECL));
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.ASSIGNATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.ASSIGNATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignationAccess().getVariableDeclVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariableDecl());
		feeder.accept(grammarAccess.getAssignationAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Backward
	 *     Backward returns Backward
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Backward(ISerializationContext context, Backward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBackwardAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Binary
	 *     Binary returns Binary
	 *
	 * Constraint:
	 *     (
	 *         Operator=BinaryOp? 
	 *         expresion=VariableDeclaration 
	 *         expression+=Expression 
	 *         expression+=Expression* 
	 *         operands+=Expression 
	 *         operands+=Expression*
	 *     )
	 * </pre>
	 */
	protected void sequence_Binary(ISerializationContext context, Binary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     {Boolean}
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, robotML.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (block+=Block block+=Block* conditions+=Expression conditions+=Expression*)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Float
	 *     Float returns Float
	 *
	 * Constraint:
	 *     {Float}
	 * </pre>
	 */
	protected void sequence_Float(ISerializationContext context, robotML.Float semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Forward
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForwardAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FunctionCall
	 *     Statement returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (
	 *         functiondeclaration=[FunctionDeclaration|EString] 
	 *         (parameters+=[Expression|EString] parameters+=[Expression|EString]*)? 
	 *         expresion=VariableDeclaration
	 *     )
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (returnType=Type block=Block (parameters+=VariableDeclaration parameters+=VariableDeclaration*)?)
	 * </pre>
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GetClock
	 *     GetClock returns GetClock
	 *
	 * Constraint:
	 *     expresion=VariableDeclaration
	 * </pre>
	 */
	protected void sequence_GetClock(ISerializationContext context, GetClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetClockAccess().getExpresionVariableDeclarationParserRuleCall_3_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GetSensor
	 *     GetSensor returns GetSensor
	 *
	 * Constraint:
	 *     (sensor=Sensor? expresion=VariableDeclaration)
	 * </pre>
	 */
	protected void sequence_GetSensor(ISerializationContext context, GetSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GetSpeed
	 *     GetSpeed returns GetSpeed
	 *
	 * Constraint:
	 *     expresion=VariableDeclaration
	 * </pre>
	 */
	protected void sequence_GetSpeed(ISerializationContext context, GetSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetSpeedAccess().getExpresionVariableDeclarationParserRuleCall_3_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Integer
	 *     Integer returns Integer
	 *
	 * Constraint:
	 *     {Integer}
	 * </pre>
	 */
	protected void sequence_Integer(ISerializationContext context, robotML.Integer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Leftward
	 *     Leftward returns Leftward
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Leftward(ISerializationContext context, Leftward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftwardAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Rightward
	 *     Rightward returns Rightward
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Rightward(ISerializationContext context, Rightward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.MOUVEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightwardAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Rotate
	 *     Rotate returns Rotate
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Rotate(ISerializationContext context, Rotate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.ROTATE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.ROTATE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotateAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetClock
	 *     SetClock returns SetClock
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_SetClock(ISerializationContext context, SetClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.SET_CLOCK__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.SET_CLOCK__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetClockAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns String
	 *     String0 returns String
	 *
	 * Constraint:
	 *     {String}
	 * </pre>
	 */
	protected void sequence_String0(ISerializationContext context, robotML.String semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Unary
	 *     Unary returns Unary
	 *
	 * Constraint:
	 *     (Operator=UnaryOp? expresion=VariableDeclaration expression+=Expression expression+=Expression* operand=Expression)
	 * </pre>
	 */
	protected void sequence_Unary(ISerializationContext context, Unary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=EString type=Type?)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     (ref=[VariableDeclaration|EString] expresion=VariableDeclaration)
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.VARIABLE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.VARIABLE_REF__REF));
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.EXPRESSION__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getRefVariableDeclarationEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotMLPackage.Literals.VARIABLE_REF__REF, false));
		feeder.accept(grammarAccess.getVariableRefAccess().getExpresionVariableDeclarationParserRuleCall_5_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Void
	 *     Void returns Void
	 *
	 * Constraint:
	 *     {Void}
	 * </pre>
	 */
	protected void sequence_Void(ISerializationContext context, robotML.Void semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns setSpeed
	 *     setSpeed returns setSpeed
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_setSpeed(ISerializationContext context, setSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotMLPackage.Literals.SET_SPEED__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotMLPackage.Literals.SET_SPEED__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetSpeedAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
