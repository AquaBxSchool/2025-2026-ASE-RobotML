// automatically generated by Xtext
grammar org.xtext.robotml.RobotML with org.eclipse.xtext.common.Terminals

import "http://www.example.org/robotML" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Assignation returns Assignation:
	'Assignation'
	'{'
		'variableDecl' variableDecl=VariableDeclaration
		'expression' expression=Expression
	'}';


Expression returns Expression:
	FunctionCall | Binary | Unary | VariableRef | GetSpeed | GetClock | GetSensor;

Type returns Type:
	String0 | Boolean | Integer | Float | Void;



Statement returns Statement:
	FunctionDeclaration | Block | Assignation | VariableDeclaration | FunctionCall | Condition | setSpeed | SetClock | Rotate | Forward | Backward | Leftward | Rightward;

VariableDeclaration returns VariableDeclaration:
	{VariableDeclaration}
	'VariableDeclaration'
	name=EString
	'{'
		('type' type=Type)?
	'}';

EString returns ecore::EString:
	STRING | ID;

String0 returns String:
	{String}
	'String'
	;

Boolean returns Boolean:
	{Boolean}
	'Boolean'
	;

Integer returns Integer:
	{Integer}
	'Integer'
	;

Float returns Float:
	{Float}
	'Float'
	;

Void returns Void:
	{Void}
	'Void'
	;

FunctionCall returns FunctionCall:
	'FunctionCall'
	'{'
		'functiondeclaration' functiondeclaration=[FunctionDeclaration|EString]
		('parameters' '(' parameters+=[Expression|EString] ( "," parameters+=[Expression|EString])* ')' )?
		'expresion' expresion=VariableDeclaration
	'}';

Binary returns Binary:
	'Binary'
	'{'
		('Operator' Operator=BinaryOp)?
		'expresion' expresion=VariableDeclaration
		'expression' '{' expression+=Expression ( "," expression+=Expression)* '}' 
		'operands' '{' operands+=Expression ( "," operands+=Expression)* '}' 
	'}';

Unary returns Unary:
	'Unary'
	'{'
		('Operator' Operator=UnaryOp)?
		'expresion' expresion=VariableDeclaration
		'expression' '{' expression+=Expression ( "," expression+=Expression)* '}' 
		'operand' operand=Expression
	'}';

VariableRef returns VariableRef:
	'VariableRef'
	'{'
		'ref' ref=[VariableDeclaration|EString]
		'expresion' expresion=VariableDeclaration
	'}';

GetSpeed returns GetSpeed:
	'GetSpeed'
	'{'
		'expresion' expresion=VariableDeclaration
	'}';

GetClock returns GetClock:
	'GetClock'
	'{'
		'expresion' expresion=VariableDeclaration
	'}';

GetSensor returns GetSensor:
	'GetSensor'
	'{'
		('sensor' sensor=Sensor)?
		'expresion' expresion=VariableDeclaration
	'}';

FunctionDeclaration returns FunctionDeclaration:
	'FunctionDeclaration'
	'{'
		'returnType' returnType=Type
		'block' block=Block
		('parameters' '{' parameters+=VariableDeclaration ( "," parameters+=VariableDeclaration)* '}' )?
	'}';

Block returns Block:
	{Block}
	'Block'
	'{'
		('statements' '{' statements+=Statement ( "," statements+=Statement)* '}' )?
	'}';

Condition returns Condition:
	'Condition'
	'{'
		'block' '{' block+=Block ( "," block+=Block)* '}' 
		'conditions' '{' conditions+=Expression ( "," conditions+=Expression)* '}' 
	'}';

setSpeed returns setSpeed:
	'setSpeed'
	'{'
		'expression' expression=Expression
	'}';

SetClock returns SetClock:
	'SetClock'
	'{'
		'expression' expression=Expression
	'}';

Rotate returns Rotate:
	'Rotate'
	'{'
		'expression' expression=Expression
	'}';

Forward returns Forward:
	'Forward'
	'{'
		'expression' expression=Expression
	'}';

Backward returns Backward:
	'Backward'
	'{'
		'expression' expression=Expression
	'}';

Leftward returns Leftward:
	'Leftward'
	'{'
		'expression' expression=Expression
	'}';

Rightward returns Rightward:
	'Rightward'
	'{'
		'expression' expression=Expression
	'}';

enum BinaryOp returns BinaryOp:
				AND = 'AND' | OR = 'OR' | NOT = 'NOT' | EQUAL = 'EQUAL' | LESSOREQUAL = 'LESSOREQUAL' | GREATEROREQUAL = 'GREATEROREQUAL' | LESS = 'LESS' | GREATER = 'GREATER' | PLUS = 'PLUS' | MINUS = 'MINUS' | TIMES = 'TIMES' | DIVIDE = 'DIVIDE' | MODULO = 'MODULO';

enum UnaryOp returns UnaryOp:
				NOTEQUAL = 'NOTEQUAL' | NEGATE = 'NEGATE';

enum Sensor returns Sensor:
				Distance = 'Distance' | Color = 'Color';
